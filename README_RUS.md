# Multithreading

1. Реализовать параллельный запуск заданного числа потоков, содержащих случайные символы из ASCII таблицы в формате гонки. Проанализировать особенности работы примитивов синхронизации. Проанализировать скорости работы примитивов.
2. Задаются данные: размер массива данных, количество параллельных потоков, значения атрибутов структуры, дополнительные данные. Результатом работы программы являются вывод времени обработки без использования многопоточности, времени обработки с использованием многопоточности и результатов обработки. 
3. Реализовать алгоритм банкира.

## Оглавление

1. [Задание 1](#задание-1) \
    1.1. [Задание 1. Теория](#задание-1-теория) \
    1.2. [Задание 1. Код](#задание-1-код)
2. [Задание 2](#задание-2) \
    2.1. [Задание 2. Код](#задание-2-код)
3. [Задание 3](#задание-3) \
    3.1. [Задание 3. Теория](#задание-3-теория) \
    3.2. [Задание 3. Код](#задание-3-код)

# Задание 1

Реализовать параллельный запуск заданного числа потоков, содержащих случайные символы из ASCII таблицы в формате гонки. 
Проанализировать особенности работы примитивов синхронизации (сравнительный анализ): 
- Mutexes 
- Semaphore 
- SemaphoreSlim 
- Barrier 
- SpinLock 
- SpinWait 
- Monitor 
Проанализировать скорости работы примитивов с использованием StopWatch и BenchMarkDotNet. 

## Задание 1. Теория

Гонка - это соревнование между потоками за доступ к общим ресурсам. В задаче реализации гонки, потоки соревнуются за доступ к гоночной дорожке, представленной массивом символов.

Примитивы синхронизации:

- Mutex (Мьютекс) - обеспечивает монопольный доступ к ресурсу. Только один поток может владеть мьютексом в определенный момент времени. Поток, который не может захватить мьютекс, блокируется и ожидает освобождения мьютекса. Часто используется, когда требуется критическая секция, доступная только одному потоку. Прост в использовании, но может вызывать проблемы с производительностью из-за блокировки.
- Semaphore (Семафор) - позволяет ограничить доступ к ресурсу до определенного числа потоков. Количество доступных разрешений задается при создании семафора. Подходит, когда ресурс может быть использован несколькими потоками, но с ограничением по их числу. Более гибок, чем мьютекс, но сложнее в использовании.
- SemaphoreSlim (Тонкий семафор) - упрощенная версия семафора с дополнительными оптимизациями для улучшения производительности. Обеспечивает счетчик разрешений, похожий на семафор, но с дополнительной легковесной реализацией. Используется, когда требуется управление доступом к ресурсам с минимальной накладной. Менее затратный по сравнению с обычным семафором, но может иметь ограниченные возможности.
- Barrier (Барьер) - синхронизирует группу потоков, ожидая, пока все они достигнут барьера, прежде чем продолжить выполнение. Обеспечивает точку сбора для потоков перед продолжением выполнения. Используется, когда необходимо дождаться завершения выполнения нескольких потоков, прежде чем продолжить. Подходит для согласованного выполнения группы задач.
- SpinLock (Спин-блокировка) - обеспечивает блокировку с использованием активного ожидания (спина) вместо пассивного. Потоки повторяют попытки захвата блокировки без перехода в состояние ожидания. Подходит для коротких критических секций. Быстрый в случае коротких задержек, но может вызывать проблемы при длительных ожиданиях.
-SpinWait (Ожидание спина) - предоставляет возможность потоку активно ожидать изменения условия вместо блокировки. Потоки повторяют попытки ожидания изменения условия без перехода в состояние ожидания. Подходит для оптимизации ожидания условий без активного использования процессора.
- Monitor (Монитор) - предоставляет монопольный доступ к ресурсу, аналогично мьютексу, но также обеспечивает дополнительные функциональности, такие как ожидание сигнала и уведомление других потоков. Используется для простых случаев синхронизации с минимальной необходимостью.

Сравнительный анализ:

- Самый быстрый примитив зависит от конкретного сценария использования и особенностей системы.
- Используемость также зависит от контекста. Например, мьютексы и семафоры часто используются, но в некоторых случаях спин-блокировка может быть более эффективной.
- Каждый примитив имеет свои сильные и слабые стороны, и выбор зависит от конкретных требований задачи.

## Задание 1. Код

`fillRaceTrack` - заполняет массив гоночной дорожки случайными символами.

`printRaceTrack` - выводит текущее состояние гоночной дорожки в консоль.

`mutexRace` - симулирует гонку с использованием мьютекса для синхронизации. id: Идентификатор потока, участвующего в гонке.

`semaphoreRace` - симулирует гонку с использованием семафора для синхронизации. 

`semaphoreSlimRace` - симулирует гонку с использованием "тонкого" семафора для синхронизации.

`spinLockRace` - симулирует гонку с использованием спин-блокировки для синхронизации.

`spinWaitRace` - симулирует гонку с использованием SpinWait для синхронизации.

`monitorRace` - cимулирует гонку с использованием монитора для синхронизации.

`barrierRace` - cимулирует гонку с использованием барьера для синхронизации.

`runRace` - запускает гонку с указанным примитивом синхронизации и выводит затраченное время.
- name: Название примитива синхронизации;
- raceFunction: Функция, представляющая гонку с конкретным примитивом.

# Задание 2 

Задаются данные: размер массива данных, количество параллельных потоков, значения атрибутов структуры, дополнительные данные. 
Результатом работы программы являются вывод времени обработки без использования многопоточности, времени обработки с использованием многопоточности и результатов обработки. 
Структура содержит сведения о школьниках, сдавших ЕГЭ (ФИО, возраст, номер школы, список результатов экзамена). Результат экзамена включает в себя название предмета и количество баллов. Необходимо вывести ТОП-3 школы по показателю наибольшего количества школьников, сдавших хотя бы один экзамен на 100 баллов. 

## Задание 2. Код

`main`:
- Запрашивает у пользователя количество студентов (dataSize) и количество потоков (numThreads).
- Генерирует случайные данные о студентах с использованием функции generateRandomStudent и сохраняет их в вектор students.
- Замеряет время выполнения и обрабатывает данные сначала в однопоточном режиме с использованием processSingleThreaded, затем в многопоточном режиме с использованием processMultiThreaded.
- Выводит результаты, включая время выполнения для каждого режима.

`generateRandomStudent` - функция генерации случайного студента:
- Принимает индекс в виде строки и генерирует случайные данные о студенте, включая оценки по математике и русскому, возраст, номер школы и результаты экзаменов по нескольким предметам.
- Выводит сгенерированные данные на экран.
- Создает и возвращает структуру Student с сгенерированными данными.

`hasPerfectScore` - проверка наличия максимальной оценки у студента:
- Принимает студента в качестве аргумента.
- Возвращает true, если у студента есть хотя бы одна максимальная оценка (100), иначе возвращает false.

`processSingleThreaded` - функция обработки данных в однопоточном режиме:
- Создает вектор школ (schools), в котором хранится информация о каждой школе (номер школы, количество студентов с максимальными баллами и их имена).
- Проходится по вектору студентов и для каждого студента с максимальной оценкой обновляет соответствующую информацию в векторе школ.
- Сортирует школы по количеству студентов с максимальными баллами в убывающем порядке.
- Выводит топ-3 школы с наибольшим количеством студентов с максимальными баллами.

`processMultiThreaded` - функция обработки данных в многопоточном режиме:
- Использует множество (schoolsMap) для хранения информации о школах вместо вектора, чтобы избежать проблемы с гонками данных при доступе из нескольких потоков.
- Создает несколько потоков для обработки частей вектора студентов параллельно.
- После завершения потоков преобразует множество в вектор и сортирует его так же, как и в processSingleThreaded.
- Выводит топ-3 школы с наибольшим количеством студентов с максимальными баллами.
processMultiThreaded использует мьютекс для обеспечения безопасности при обновлении данных об общем количестве студентов с максимальными баллами во всех потоках.

# Задание 3

Реализовать алгоритм банкира.

## Задание 3. Теория

Алгоритм банкира - это алгоритм, который используется для предотвращения возникновения дефицита ресурсов в многозадачных системах.

Допустим, у нас есть некоторое количество ресурсов, например, процессорное время или память, и несколько процессов, которые могут запрашивать эти ресурсы. Цель алгоритма банкира - предотвратить ситуации, когда процессы запрашивают больше ресурсов, чем доступно, что может привести к блокировке системы.

Алгоритм банкира работает следующим образом:

1. В начале каждый процесс объявляет, сколько ресурсов он может потреблять во время своей работы. Это называется максимальным потреблением.
2. Когда процесс запрашивает ресурсы, система проверяет, не превышает ли запрошенное количество его максимальное потребление. Если да, то запрос может быть отклонен.
3. Если запрос удовлетворяет требованиям, система временно выделяет ресурсы процессу. Однако система не разрешает выделение ресурсов, если это может привести к ситуации, в которой не будет достаточно ресурсов, чтобы удовлетворить запросы других процессов.
4. Если система выделяет ресурсы процессу, процесс их использует. Когда процесс закончил использование ресурсов, он возвращает их системе.
5. Если система не может выделить ресурсы процессу, то процесс должен ждать до тех пор, пока ресурсы не станут доступными.

Алгоритм банкира гарантирует, что если система находится в безопасном состоянии перед выделением ресурсов, то она останется безопасной и после выделения. Другими словами, алгоритм банкира предотвращает блокировку системы и обеспечивает правильную управляемость ресурсами. Это особенно важно в многозадачных системах, где несколько процессов работают одновременно и конкурируют за ресурсы.

Основные понятия в алгоритме банкира:
- Максимальное количество ресурсов (Maximum): Это максимальное количество ресурсов, которое процесс может запросить в процессе выполнения.
- Выделенные ресурсы (Allocation): Это количество ресурсов, которые уже выделены процессу.
- Оставшиеся (неудовлетворенные) потребности (Need): Это разница между максимальным количеством ресурсов и выделенными ресурсами. Таким образом, Need[i, j] = Maximum[i, j] - Allocation[i, j].
- Доступные ресурсы (Available): Это количество ресурсов, которые в данный момент доступны системе для выделения процессам.

## Задание 3. Код

`isSafe` - проверяет, находится ли система в безопасном состоянии с использованием алгоритма банкира.

- Использует вектор work для отслеживания доступных ресурсов во время проверки.
- Использует вектор finish для отслеживания завершенных процессов.
- Использует вектор safeSequence для формирования безопасной последовательности выполнения.
- Использует цикл while для проверки каждого процесса на возможность выделения ему ресурсов.

В случае успешной проверки выводит безопасную последовательность выполнения и возвращает true.
Если не удается найти подходящий процесс, выводит сообщение и возвращает false.

`updateNeedMatrix`- обновляет матрицу need на основе текущих значений в матрицах maximum и allocation. Использует два вложенных цикла для перебора каждого элемента матриц.

`checkNeedLessOrEqual`- проверяет, может ли процесс удовлетворить свои потребности с текущими доступными ресурсами.

>
>fratellou, 2024